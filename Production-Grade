PHASE 0 â€” Prerequisites (If this is weak, everything collapses)
-------------------------------------------------------------------
OS & Debugging â€” Linux â€” Production runs on Linux. If you canâ€™t navigate processes, permissions, filesystems, you are helpless when things break.
- 00:00:00â€Š-â€ŠCourse Orientation & Why Linux / CLI Matters
- 00:15:00â€Š-â€ŠTerminals, Shells & CLI Fundamentals
- 00:30:00â€Š-â€ŠShell Productivity & Command History
- 00:45:00â€Š-â€ŠFilesystem Basics & Navigation
- 01:00:00â€Š-â€ŠFile Inspection & Text Viewing
- 01:15:00â€Š-â€ŠFile & Directory Manipulation
- 01:30:00â€Š-â€ŠSearch & Discovery Tools
- 01:45:00â€Š-â€ŠUsers, Permissions & Security
- 02:00:00â€Š-â€ŠPrograms, Execution & PATH
- 02:15:00â€Š-â€ŠInput / Output & Process Control
- 02:30:00â€Š-â€ŠUnix Philosophy & Package Management
Version Control â€” Git & GitHub â€” This is not optional collaboration hygiene. Itâ€™s how experiments, pipelines, infra, and rollbacks survive reality.
- 00:00:00â€Š-â€ŠWhat Git Is (and Is Not)
- 00:15:00â€Š-â€ŠRepositories, States & Daily Commands
- 00:30:00â€Š-â€ŠCommits, History & Internals (Mental Model)
- 00:45:00â€Š-â€ŠBranching (The Only Definition That Matters)
- 01:00:00â€Š-â€Šgit log Mastery & Branch Internals
- 01:15:00â€Š-â€ŠMerge Commits & Merge Base
- 01:30:00â€Š-â€ŠFast-Forward vs True Merge
- 01:45:00â€Š-â€ŠRebase Fundamentals (Mental Model)
- 02:00:00â€Š-â€ŠMerging, Pulls & Diverging Branches
- 02:15:00â€Š-â€ŠPull Requests, Solo vs Team Workflow
- 02:30:00â€Š-â€Š.gitignore Deep Dive
- 02:45:00â€Š-â€ŠLocal Ignores, Generated Files & Cleanup
- 03:00:00â€Š-â€ŠConflict Resolution: ours vs theirs
- 03:15:00â€Š-â€ŠRebase Conflicts (Why Roles Flip)
- 03:30:00â€Š-â€Šrerere, Squash & History Surgery
- 03:45:00â€Š-â€ŠStash, Revert, Cherry-Pick & Bisect
- 04:00:00â€Š-â€ŠBisect (Find the Bug, Fast)
- 04:15:00â€Š-â€ŠWorktrees + Tags (Parallel Work & Releases)
Programming â€” Python â€” ML is Python-first. Even when performance-critical parts arenâ€™t, orchestration and glue code are.
- 00:00:00â€Š-â€ŠCourse Orientation & Python Execution Fundamentals
- 00:15:00â€Š-â€ŠWorking with Strings & `print()` Deep Dive
- 00:30:00â€Š-â€ŠVariables, Data Types, Type Casting & Code Structure
- 00:45:00â€Š-â€ŠString Indexing, Slicing & Built-in Methods
- 01:00:00â€Š-â€ŠHands-on String Operations
- 01:15:00â€Š-â€ŠConditional Logic: `if`, `elif`, `else`
- 01:30:00â€Š-â€Š`for` Loops: Iteration as a Data Engineering Primitive
- 01:45:00â€Š-â€ŠLoop Control: `break`, `continue` & `while` Loops
- 02:00:00â€Š-â€ŠAdvanced List Operations: Reversal & Slicing
- 02:15:00â€Š-â€ŠList Comprehensions for High-Productivity Code
- 02:30:00 - Core Data Structures: Dictionaries, Sets & Tuples
- 02:45:00â€Š-â€ŠWriting Functions: `def`, `return`, `*args`, `**kwargs`
- 03:00:00â€Š-â€ŠException Handling: Writing Failure-Resistant Code
- 03:15:00â€Š-â€Š`return` vs `finally` & Function Execution Flow
- 03:30:00â€Š-â€ŠVariable Scope, Globals & Raising Custom Exceptions
- 03:45:00â€Š-â€Š`enumerate()` & Object-Oriented ProgrammingÂ 
- 04:00:00â€Š-â€ŠOOP Method Types: Instance, Class & Static Methods
- 04:15:00â€Š-â€ŠGetters & Setters: The Pythonic Approach
- 04:30:00â€Š-â€ŠInheritance with Real-World Use Cases
- 04:50:00â€Š-â€ŠMultiple Inheritance & Introduction to Multithreading
- 05:00:00â€Š-â€ŠSimulating Workloads: `sleep`, `random` & Sequential Execution
- 05:15:00â€Š-â€ŠParallel Execution: `ThreadPoolExecutor`, `map()` & `requests`
Environments â€” Virtual Environments â€” Dependency hell kills teams. Reproducibility starts here, not with Docker.
- 00:00:00â€Š-â€ŠWhy Virtual Environments Exist (Dependency & Version)
- 00:01:20â€Š-â€ŠWhat a Virtual Environment Is (Python Version + Libraries)
- 00:02:10â€Š-â€ŠHow Python Imports Work (sys.path Explained)
- 00:03:55â€Š-â€ŠCreating a Virtual Environment with venv
- 00:06:10â€Š-â€ŠActivating a Virtual Environment (Windows / macOS / Linux)
- 00:07:25â€Š-â€ŠHow PATH Changes When a Virtual Environment Is Activated
- 00:09:55â€Š-â€ŠInstalling Packages Inside a Virtual Environment (pip)
- 00:11:55â€Š-â€ŠManaging Dependencies with requirements.txt
- 00:13:40â€Š-â€ŠVersion Pinning & Semantic Versioning (Best Practices)
- 00:15:10â€Š-â€ŠWhen to Use venv vs Pipenv (Final Advice)
Databases â€” SQL | Data doesnâ€™t magically appear as CSVs. SQL is how you interrogate reality.
- 00:00:00â€Š-â€ŠSQL Foundations & Schema Basics
- 00:00:15â€Š-â€ŠData Manipulation & Filtering
- 00:00:30â€Š-â€ŠSorting, Limiting & Aggregation Basics
- 00:00:45â€Š-â€ŠJOIN Fundamentals
- 01:00:00â€Š-â€ŠAdvanced Joins & Set Operations
- 01:15:00â€Š-â€ŠConditional Logic & NULL Handling
- 01:30:00â€Š-â€ŠString, Date & Math Functions
- 01:45:00â€Š-â€ŠWindow Functions: Core Concepts
- 02:00:00â€Š-â€ŠRanking & Partitioning
- 02:15:00â€Š-â€ŠAdvanced Window Analytics
- 02:30:00â€Š-â€ŠAggregations with Window Functions
- 02:45:00â€Š-â€ŠSubqueries: Core Mechanics
- 03:00:00â€Š-â€ŠCorrelated & Derived Subqueries
  03:15:00â€Š-â€ŠComplex Subquery Refactoring
  03:30:00â€Š-â€ŠSubquery Performance & Limits
  03:45:00â€Š-â€ŠIntroduction to CTEs
  04:00:00â€Š-â€ŠRewriting Logic Using CTEs
  04:15:00â€Š-â€ŠIN Operator & Pattern Replacement
  04:30:00â€Š-â€ŠRanking Scenarios & Deduplication
  04:45:00â€Š-â€ŠLAG & LEAD Analytics
  05:00:00â€Š-â€ŠViews & Reusable Queries
  05:15:00â€Š-â€ŠStored Procedures
  05:30:00â€Š-â€ŠSQL User-Defined Functions
  05:45:00â€Š-â€ŠFunctions vs Stored Procedures
  06:00:00â€Š-â€ŠWhat Comes After SQL
Debugging â€” System Logs & Process Inspection | When training jobs die at 2 a.m., logs are the only truth you get.
- 00:00:00â€Š-â€ŠWhy Debugging Separates Real Developers
- 00:01:35â€Š-â€ŠYou Can't Debug What You Don't Understand
- 00:02:20â€Š-â€ŠSystem Flow: Frontend â†’ Backend â†’ Database
- 00:03:10â€Š-â€ŠDebugging in Large, Existing Codebases
- 00:03:50â€Š-â€ŠDrawing the System to Understand It
- 00:04:55â€Š-â€ŠThe Cost of Skipping Codebase Understanding
- 00:05:25â€Š-â€ŠDebuggers vs Console Logs
- 00:06:20â€Š-â€ŠDebugging Async & Event-Driven Code
- 00:06:55â€Š-â€ŠAI Coding Requires Strong Tests
- 00:07:40â€Š-â€ŠDebugging at Scale (Microsoft Story)
- 00:08:35â€Š-â€ŠLogs, Telemetry & Observability
  00:09:30â€Š-â€ŠPII-Safe Logging & Traceability
  00:10:30â€Š-â€ŠDebugging Rule: Assume Nothing
  00:11:10â€Š-â€ŠBinary Search Debugging Method
  00:12:45â€Š-â€ŠAfter Fixing the Bug (Top 5% Habit)
  00:13:30â€Š-â€ŠTests, Docs & Team Learning
  00:14:25â€Š-â€ŠBecoming an Exceptional Developer

PHASE 1 â€” Math Intuition (You donâ€™t need proofs, you need instinct)
-----------------------------------------------------------------------
Linear Algebra â€” Vectors, Matrices | ML models are linear algebra. If this feels abstract, models will feel like magic â€” and magic fails silently.
- 00:00:00 â€” Why Linear Algebra Feels Scary (And Why It Shouldnâ€™t)
- 00:01:20 â€” Vectors & the Dot Product (Similarity Engine)
- 00:06:51 â€” Linear Systems: Ax = b & Gaussian Elimination
- 00:12:30 â€” Vector Spaces, Span & Basis (Rules of the World)
- 00:18:15 â€” Linear Transformations (Matrices Are Actions)
- 00:23:25 â€” Determinants (One Number That Tells Everything)
- 00:28:57 â€” Conclusion & What This Unlocks Next
Optimization â€” Gradient Descent | Training is optimization. No intuition here = no intuition for convergence, divergence, or learning rates.
- Momentum Gradient Descent
- Stochastic Gradient Descent
- Gradient Descent
Neural Nets â€” Fundamentals | Even if you donâ€™t build them, youâ€™ll debug, deploy, and monitor them.
- What a Neural Network Actually Is
- Learning Mechanism: Gradient Descent
- Backpropagation (Intuition First)
- Backpropagation (Math Reality Check)
- What LLMs Are (High-Level Reality)
- Transformers: The Real Breakthrough
- Attention Mechanism (Step-by-Step)
- How LLMs Store â€œFactsâ€
- How AI Generates Images & Video
Probability â€” Distributions | Uncertainty is the entire game. Predictions without probability thinking are lies.
Calculus â€” Differential / Integral / Multivariable | Backprop, loss surfaces, gradients â€” this is the language models speak.

PHASE 2 â€” ML Theory Foundations (This separates engineers from button-clickers)
-----------------------------------------------------------------------------------
ML Framework â€” scikit-learn | Baseline models. Sanity checks. Fast iteration. If your deep model canâ€™t beat this, stop.
  00:00:00â€” Overview & ML Workflow (What This Video Covers)
  00:15:00 â€” Working with Datasets in Scikit-Learn (Load, Fetch, Generate)
  00:30:00 â€” Data Splitting Strategies (Train/Test, Stratified Splits)
  00:45:00 â€” Data Preprocessing (Scaling, Encoding, Feature Prep)
  01:00:00 â€” Supervised Learning (Classification & Regression)
  01:15:00 â€” Unsupervised Learning & Dimensionality Reduction
  01:30:00 â€” Model Evaluation, Tuning & Pipelines (Metrics, CV, GridSearch)
Regression â€” Linear Regression | The â€œhello worldâ€ of modeling â€” and shockingly effective in real systems.
  00:00:00 â€” Linear Regression â€” Theory & Optimization
  00:15:00 â€” Coding Linear Regression From Scratch
Tree Models â€” Decision Trees | Interpretability and non-linearity without neural complexity.
Ensembles â€” Random Forests | Bias reduction without fragile tuning.
Metrics â€” Accuracy, Precision, Recall, F1 | Wrong metric = wrong business decision = wasted model.
Ranking Metrics â€” ROCâ€“AUC | Binary classification isnâ€™t binary in production.
Regularization â€” Ridge, Lasso, Elastic | Net Overfitting is the default. Regularization is the antidote.
Validation â€” Cross-Validation | One train-test split is amateur hour.
Risk Analysis â€” Biasâ€“Variance | Explains why your model fails, not just that it failed.
Data Risk â€” Leakage Detection | Leakage gets you fake success and real-world embarrassment.

PHASE 3 â€” Data Handling (Most ML failures happen here)
----------------------------------------------------------
Data Manipulation â€” Pandas Exploration, cleaning, feature prep â€” the unglamorous core.
Numerical Computing â€” NumPy Performance, vectorization, memory control.
Storage Formats â€” Parquet Scales better than CSV. Faster. Cheaper.
Columnar Memory â€” Apache Arrow Zero-copy data sharing. Critical at scale.
Data Quality â€” Great Expectations Bad data silently kills models. This catches it early.
Profiling â€” ydata-profiling You canâ€™t fix what you donâ€™t understand.
Big Data (Awareness) â€” Apache Spark You may not use it daily, but you must understand its trade-offs.
Lakehouse (Awareness) â€” Delta Lake Modern data platforms are built on this idea.

PHASE 4 â€” Python Engineering (ML code is still software)
------------------------------------------------------------
OOP â€” Python OOP Reusable pipelines, clean abstractions, testable code.
Testing â€” pytest Models change. Bugs multiply. Tests keep sanity.
Logging â€” Python logging Print statements donâ€™t scale past your laptop.
Typing â€” Type Hints Prevents entire classes of bugs before runtime.
Dependency Mgmt â€” Dependency Injection Decouples components. Makes systems evolvable.
Profiling â€” Performance Profilers Slow models cost money. This tells you where.

PHASE 5 â€” MLOps (Where most ML careers stall)
-------------------------------------------------
Data Versioning â€” DVC Models are meaningless without the data version that created them.
Experiment Tracking â€” MLflow If you canâ€™t reproduce a result, it doesnâ€™t exist.
Feature Stores â€” Feast Prevents trainingâ€“serving skew.
ML Monitoring â€” Evidently / Arize Models rot. Drift is inevitable.
Pipelines â€” End-to-End ML Pipelines Manual steps donâ€™t scale. Automation is survival.

PHASE 6 â€” DevOps (ML doesnâ€™t get special treatment in prod)
---------------------------------------------------------------
Containers â€” Docker â€œIf it works on my machineâ€ is not an excuse.
Orchestration â€” Kubernetes Scaling, resilience, scheduling â€” solved problems you shouldnâ€™t re-invent.
Packaging â€” Helm Deployments without chaos.
Observability â€” Prometheus, Grafana If you canâ€™t see it, you canâ€™t fix it.
Infrastructure as Code â€” Terraform Manual infra is technical debt on day one.
CI/CD â€” GitHub Actions, Azure DevOps Shipping models should be boring and repeatable.
Deployment â€” Blue-Green, Canary Minimize blast radius when things go wrong â€” because they will.

PHASE 7 â€” Security (Ignored until breach, then panic)
---------------------------------------------------------
Identity â€” Managed Identity No hardcoded credentials. Ever.
Secrets â€” Key Vault Secrets in code = breach waiting to happen.
Authorization â€” RBAC Least privilege is non-negotiable.
Supply Chain â€” Snyk, Aqua Dependencies are attack vectors.
ML Security â€” OWASP ML Top 10 Models can be attacked, poisoned, exploited.
LLM Security â€” OWASP LLM Top 10 Prompt injection and data exfiltration are real threats.
Reliability â€” Chaos Engineering Systems fail. Design for it. 

PHASE 8 â€” Cloud for MLOps (Where budgets go to die if unmanaged)
--------------------------------------------------------------------
Cloud Platform â€” Azure Enterprise ML lives here.
Compute â€” Azure Compute Right-size or burn money.
Storage â€” Azure Storage Cost, latency, durability trade-offs matter.
Networking â€” Azure Networking Security and performance depend on this.
ML Platform â€” Azure ML Managed experimentation, training, deployment.
Monitoring â€” Azure Monitor Cloud-native observability.
Cost Control â€” Azure Cost Management Your model isnâ€™t impressive if itâ€™s unaffordable.

PHASE 9 â€” Orchestration (Glue for everything above)
-------------------------------------------------------
Workflow Engine â€” Airflow Complex dependencies, retries, scheduling.
Orchestration (Alt) â€” Prefect More Pythonic, less ops-heavy alternative.

PHASE 10 â€” LLMOps (Modern ML reality)
-----------------------------------------
Inference Engines â€” vLLM / Triton | Serving LLMs efficiently is a different game.
Optimization â€” Quantization | Inference costs matter more than training.
Vector Search â€” Vector Databases | RAG doesnâ€™t work without this.
Serving â€” FastAPI | Models are APIs, not notebooks.
LLM Monitoring â€” LangSmith / Arize | LLMs fail in creative, dangerous ways.

PHASE 11 â€” Portfolio (Proof beats certificates)
---------------------------------------------------
Reproducibility â€” Docker | Anyone should be able to run your work.
Orchestration â€” Airflow | Shows system-level thinking.
ML Lifecycle â€” MLflow | Demonstrates experiment discipline.
Cloud ML â€” Azure ML | Signals production readiness.
Monitoring â€” Observability | Stack Shows you understand failure.
Cost Tracking â€” Dashboards | Senior engineers think in money.
---------------------------------------------------
Donâ€™t argue â€” argument invites emotional wrestling. Once you argue, youâ€™ve accepted theyâ€™re a judge.
Donâ€™t justify â€” justification asks for approval. Children justify to parents.
Donâ€™t overshare â€” oversharing hands them leverage. Oversharing signals low status.
I exist to translate ambiguous business problems into trustworthy, deployable AI/ML systems that actually get used.
My mission is to design AI/ML solutions that survive real-world constraintsâ€”data quality, stakeholders, scale, and regulation.
Pick ONE. Donâ€™t Frankenstein them.
____________________________________________________
Best Scholarships:
Government of Ireland International Education Scholarship (GOI-IES)
Ireland isnâ€™t generous compared to Canada/EU on taught Masterâ€™s scholarships â€” fully funded options are rare unless youâ€™re exceptionally strong academically or the program itself offers departmental awards.
Government-level scholarships often require research proposals or connections with supervisors â€” not ideal if you just want a taught Masterâ€™s without research.
Go for every single university-level award youâ€™re eligible for, because institutional scholarships often have higher acceptance rates than national ones.
Create a scholarship spreadsheet tracking deadlines + requirements.
University of Limerick â€“ International Merit Scholarship
ğŸ‘‰ Ireland makes sense.
ğŸ‘‰ Ireland is the wrong country.
Ireland without GOI-IES = expensive bet, but a bet that can pay off if you execute well.
