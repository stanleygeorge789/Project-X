PHASE 0 — Prerequisites (If this is weak, everything collapses)
-------------------------------------------------------------------
OS & Debugging — Linux — Production runs on Linux. If you can’t navigate processes, permissions, filesystems, you are helpless when things break.
  00:00:00 - Course Orientation & Why Linux / CLI Matters
  00:15:00 - Terminals, Shells & CLI Fundamentals
  00:30:00 - Shell Productivity & Command History
  00:45:00 - Filesystem Basics & Navigation
  01:00:00 - File Inspection & Text Viewing
  01:15:00 - File & Directory Manipulation
  01:30:00 - Search & Discovery Tools
  01:45:00 - Users, Permissions & Security
  02:00:00 - Programs, Execution & PATH
  02:15:00 - Input / Output & Process Control
  02:30:00 - Unix Philosophy & Package Management
Version Control — Git & GitHub — This is not optional collaboration hygiene. It’s how experiments, pipelines, infra, and rollbacks survive reality.
  00:00:00 - What Git Is (and Is Not)
  00:15:00 - Repositories, States & Daily Commands
  00:30:00 - Commits, History & Internals (Mental Model)
  00:45:00 - Branching (The Only Definition That Matters)
  01:00:00 - git log Mastery & Branch Internals
  01:15:00 - Merge Commits & Merge Base
  01:30:00 - Fast-Forward vs True Merge
  01:45:00 - Rebase Fundamentals (Mental Model)
  02:00:00 - Merging, Pulls & Diverging Branches
  02:15:00 - Pull Requests, Solo vs Team Workflow
  02:30:00 - .gitignore Deep Dive
  02:45:00 - Local Ignores, Generated Files & Cleanup
  03:00:00 - Conflict Resolution: ours vs theirs
  03:15:00 - Rebase Conflicts (Why Roles Flip)
  03:30:00 - rerere, Squash & History Surgery
  03:45:00 - Stash, Revert, Cherry-Pick & Bisect
  04:00:00 - Bisect (Find the Bug, Fast)
  04:15:00 - Worktrees + Tags (Parallel Work & Releases)
Programming — Python — ML is Python-first. Even when performance-critical parts aren’t, orchestration and glue code are.
  00:00:00 - Course Orientation & Python Execution Fundamentals
  00:15:00 - Working with Strings & `print()` Deep Dive
  00:30:00 - Variables, Data Types, Type Casting & Code Structure
  00:45:00 - String Indexing, Slicing & Built-in Methods
  01:00:00 - Hands-on String Operations
  01:15:00 - Conditional Logic: `if`, `elif`, `else`
  01:30:00 - `for` Loops: Iteration as a Data Engineering Primitive
  01:45:00 - Loop Control: `break`, `continue` & `while` Loops
  02:00:00 - Advanced List Operations: Reversal & Slicing
  02:15:00 - List Comprehensions for High-Productivity Code
  02:30:00 - Core Data Structures: Dictionaries, Sets & Tuples
  02:45:00 - Writing Functions: `def`, `return`, `*args`, `**kwargs`
  03:00:00 - Exception Handling: Writing Failure-Resistant Code
  03:15:00 - `return` vs `finally` & Function Execution Flow
  03:30:00 - Variable Scope, Globals & Raising Custom Exceptions
  03:45:00 - `enumerate()` & Object-Oriented Programming 
  04:00:00 - OOP Method Types: Instance, Class & Static Methods
  04:15:00 - Getters & Setters: The Pythonic Approach
  04:30:00 - Inheritance with Real-World Use Cases
  04:50:00 - Multiple Inheritance & Introduction to Multithreading
  05:00:00 - Simulating Workloads: `sleep`, `random` & Sequential Execution
  05:15:00 - Parallel Execution: `ThreadPoolExecutor`, `map()` & `requests`
Environments — Virtual Environments — Dependency hell kills teams. Reproducibility starts here, not with Docker.
  00:00:00 - Why Virtual Environments Exist (Dependency & Version)
  00:01:20 - What a Virtual Environment Is (Python Version + Libraries)
  00:02:10 - How Python Imports Work (sys.path Explained)
  00:03:55 - Creating a Virtual Environment with venv
  00:06:10 - Activating a Virtual Environment (Windows / macOS / Linux)
  00:07:25 - How PATH Changes When a Virtual Environment Is Activated
  00:09:55 - Installing Packages Inside a Virtual Environment (pip)
  00:11:55 - Managing Dependencies with requirements.txt
  00:13:40 - Version Pinning & Semantic Versioning (Best Practices)
  00:15:10 - When to Use venv vs Pipenv (Final Advice)
Databases — SQL | Data doesn’t magically appear as CSVs. SQL is how you interrogate reality.
  00:00:00 - SQL Foundations & Schema Basics
  00:00:15 - Data Manipulation & Filtering
  00:00:30 - Sorting, Limiting & Aggregation Basics
  00:00:45 - JOIN Fundamentals
  01:00:00 - Advanced Joins & Set Operations
  01:15:00 - Conditional Logic & NULL Handling
  01:30:00 - String, Date & Math Functions
  01:45:00 - Window Functions: Core Concepts
  02:00:00 - Ranking & Partitioning
  02:15:00 - Advanced Window Analytics
  02:30:00 - Aggregations with Window Functions
  02:45:00 - Subqueries: Core Mechanics
  03:00:00 - Correlated & Derived Subqueries
  03:15:00 - Complex Subquery Refactoring
  03:30:00 - Subquery Performance & Limits
  03:45:00 - Introduction to CTEs
  04:00:00 - Rewriting Logic Using CTEs
  04:15:00 - IN Operator & Pattern Replacement
  04:30:00 - Ranking Scenarios & Deduplication
  04:45:00 - LAG & LEAD Analytics
  05:00:00 - Views & Reusable Queries
  05:15:00 - Stored Procedures
  05:30:00 - SQL User-Defined Functions
  05:45:00 - Functions vs Stored Procedures
  06:00:00 - What Comes After SQL
Debugging — System Logs & Process Inspection | When training jobs die at 2 a.m., logs are the only truth you get.
  00:00:00 - Why Debugging Separates Real Developers
  00:01:35 - You Can't Debug What You Don't Understand
  00:02:20 - System Flow: Frontend → Backend → Database
  00:03:10 - Debugging in Large, Existing Codebases
  00:03:50 - Drawing the System to Understand It
  00:04:55 - The Cost of Skipping Codebase Understanding
  00:05:25 - Debuggers vs Console Logs
  00:06:20 - Debugging Async & Event-Driven Code
  00:06:55 - AI Coding Requires Strong Tests
  00:07:40 - Debugging at Scale (Microsoft Story)
  00:08:35 - Logs, Telemetry & Observability
  00:09:30 - PII-Safe Logging & Traceability
  00:10:30 - Debugging Rule: Assume Nothing
  00:11:10 - Binary Search Debugging Method
  00:12:45 - After Fixing the Bug (Top 5% Habit)
  00:13:30 - Tests, Docs & Team Learning
  00:14:25 - Becoming an Exceptional Developer

PHASE 1 — Math Intuition (You don’t need proofs, you need instinct)
-----------------------------------------------------------------------
Linear Algebra — Vectors, Matrices | ML models are linear algebra. If this feels abstract, models will feel like magic — and magic fails silently.
  00:00:00 — Why Linear Algebra Feels Scary (And Why It Shouldn’t)
  00:01:20 — Vectors & the Dot Product (Similarity Engine)
  00:06:51 — Linear Systems: Ax = b & Gaussian Elimination
  00:12:30 — Vector Spaces, Span & Basis (Rules of the World)
  00:18:15 — Linear Transformations (Matrices Are Actions)
  00:23:25 — Determinants (One Number That Tells Everything)
  00:28:57 — Conclusion & What This Unlocks Next
Optimization — Gradient Descent | Training is optimization. No intuition here = no intuition for convergence, divergence, or learning rates.
  Momentum Gradient Descent
  Stochastic Gradient Descent
  Gradient Descent
Neural Nets — Fundamentals | Even if you don’t build them, you’ll debug, deploy, and monitor them.
  What a Neural Network Actually Is
  Learning Mechanism: Gradient Descent
  Backpropagation (Intuition First)
  Backpropagation (Math Reality Check)
  What LLMs Are (High-Level Reality)
  Transformers: The Real Breakthrough
  Attention Mechanism (Step-by-Step)
  How LLMs Store “Facts”
  How AI Generates Images & Video
Probability — Distributions | Uncertainty is the entire game. Predictions without probability thinking are lies.
Calculus — Differential / Integral / Multivariable | Backprop, loss surfaces, gradients — this is the language models speak.

PHASE 2 — ML Theory Foundations (This separates engineers from button-clickers)
-----------------------------------------------------------------------------------
ML Framework — scikit-learn | Baseline models. Sanity checks. Fast iteration. If your deep model can’t beat this, stop.
  00:00:00— Overview & ML Workflow (What This Video Covers)
  00:15:00 — Working with Datasets in Scikit-Learn (Load, Fetch, Generate)
  00:30:00 — Data Splitting Strategies (Train/Test, Stratified Splits)
  00:45:00 — Data Preprocessing (Scaling, Encoding, Feature Prep)
  01:00:00 — Supervised Learning (Classification & Regression)
  01:15:00 — Unsupervised Learning & Dimensionality Reduction
  01:30:00 — Model Evaluation, Tuning & Pipelines (Metrics, CV, GridSearch)
Regression — Linear Regression | The “hello world” of modeling — and shockingly effective in real systems.
  00:00:00 — Linear Regression — Theory & Optimization
  00:15:00 — Coding Linear Regression From Scratch
Tree Models — Decision Trees | Interpretability and non-linearity without neural complexity.
Ensembles — Random Forests | Bias reduction without fragile tuning.
Metrics — Accuracy, Precision, Recall, F1 | Wrong metric = wrong business decision = wasted model.
Ranking Metrics — ROC–AUC | Binary classification isn’t binary in production.
Regularization — Ridge, Lasso, Elastic | Net Overfitting is the default. Regularization is the antidote.
Validation — Cross-Validation | One train-test split is amateur hour.
Risk Analysis — Bias–Variance | Explains why your model fails, not just that it failed.
Data Risk — Leakage Detection | Leakage gets you fake success and real-world embarrassment.

PHASE 3 — Data Handling (Most ML failures happen here)
----------------------------------------------------------
Data Manipulation — Pandas Exploration, cleaning, feature prep — the unglamorous core.
Numerical Computing — NumPy Performance, vectorization, memory control.
Storage Formats — Parquet Scales better than CSV. Faster. Cheaper.
Columnar Memory — Apache Arrow Zero-copy data sharing. Critical at scale.
Data Quality — Great Expectations Bad data silently kills models. This catches it early.
Profiling — ydata-profiling You can’t fix what you don’t understand.
Big Data (Awareness) — Apache Spark You may not use it daily, but you must understand its trade-offs.
Lakehouse (Awareness) — Delta Lake Modern data platforms are built on this idea.

PHASE 4 — Python Engineering (ML code is still software)
------------------------------------------------------------
OOP — Python OOP Reusable pipelines, clean abstractions, testable code.
Testing — pytest Models change. Bugs multiply. Tests keep sanity.
Logging — Python logging Print statements don’t scale past your laptop.
Typing — Type Hints Prevents entire classes of bugs before runtime.
Dependency Mgmt — Dependency Injection Decouples components. Makes systems evolvable.
Profiling — Performance Profilers Slow models cost money. This tells you where.

PHASE 5 — MLOps (Where most ML careers stall)
-------------------------------------------------
Data Versioning — DVC Models are meaningless without the data version that created them.
Experiment Tracking — MLflow If you can’t reproduce a result, it doesn’t exist.
Feature Stores — Feast Prevents training–serving skew.
ML Monitoring — Evidently / Arize Models rot. Drift is inevitable.
Pipelines — End-to-End ML Pipelines Manual steps don’t scale. Automation is survival.

PHASE 6 — DevOps (ML doesn’t get special treatment in prod)
---------------------------------------------------------------
Containers — Docker “If it works on my machine” is not an excuse.
Orchestration — Kubernetes Scaling, resilience, scheduling — solved problems you shouldn’t re-invent.
Packaging — Helm Deployments without chaos.
Observability — Prometheus, Grafana If you can’t see it, you can’t fix it.
Infrastructure as Code — Terraform Manual infra is technical debt on day one.
CI/CD — GitHub Actions, Azure DevOps Shipping models should be boring and repeatable.
Deployment — Blue-Green, Canary Minimize blast radius when things go wrong — because they will.

PHASE 7 — Security (Ignored until breach, then panic)
---------------------------------------------------------
Identity — Managed Identity No hardcoded credentials. Ever.
Secrets — Key Vault Secrets in code = breach waiting to happen.
Authorization — RBAC Least privilege is non-negotiable.
Supply Chain — Snyk, Aqua Dependencies are attack vectors.
ML Security — OWASP ML Top 10 Models can be attacked, poisoned, exploited.
LLM Security — OWASP LLM Top 10 Prompt injection and data exfiltration are real threats.
Reliability — Chaos Engineering Systems fail. Design for it. 

PHASE 8 — Cloud for MLOps (Where budgets go to die if unmanaged)
--------------------------------------------------------------------
Cloud Platform — Azure Enterprise ML lives here.
Compute — Azure Compute Right-size or burn money.
Storage — Azure Storage Cost, latency, durability trade-offs matter.
Networking — Azure Networking Security and performance depend on this.
ML Platform — Azure ML Managed experimentation, training, deployment.
Monitoring — Azure Monitor Cloud-native observability.
Cost Control — Azure Cost Management Your model isn’t impressive if it’s unaffordable.

PHASE 9 — Orchestration (Glue for everything above)
-------------------------------------------------------
Workflow Engine — Airflow Complex dependencies, retries, scheduling.
Orchestration (Alt) — Prefect More Pythonic, less ops-heavy alternative.

PHASE 10 — LLMOps (Modern ML reality)
-----------------------------------------
Inference Engines — vLLM / Triton | Serving LLMs efficiently is a different game.
Optimization — Quantization | Inference costs matter more than training.
Vector Search — Vector Databases | RAG doesn’t work without this.
Serving — FastAPI | Models are APIs, not notebooks.
LLM Monitoring — LangSmith / Arize | LLMs fail in creative, dangerous ways.

PHASE 11 — Portfolio (Proof beats certificates)
---------------------------------------------------
Reproducibility — Docker | Anyone should be able to run your work.
Orchestration — Airflow | Shows system-level thinking.
ML Lifecycle — MLflow | Demonstrates experiment discipline.
Cloud ML — Azure ML | Signals production readiness.
Monitoring — Observability | Stack Shows you understand failure.
Cost Tracking — Dashboards | Senior engineers think in money.
---------------------------------------------------
Don’t argue — argument invites emotional wrestling. Once you argue, you’ve accepted they’re a judge.
Don’t justify — justification asks for approval. Children justify to parents.
Don’t overshare — oversharing hands them leverage. Oversharing signals low status.

I exist to translate ambiguous business problems into trustworthy, deployable AI/ML systems that actually get used.
